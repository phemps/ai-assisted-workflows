#!/usr/bin/env python3
"""
Makefile generator for development monitoring.
Creates Makefile with component-specific targets based on LLM analysis.
"""

import sys
import argparse
import json
from pathlib import Path
from datetime import datetime

def generate_makefile_header(components_info):
    """Generate Makefile header with project information."""
    return f"""# Development Monitoring Makefile
# Generated by setup-dev-monitoring on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Components: {', '.join([c.get('label', c.get('name', 'unknown')) for c in components_info])}

# WARNING: Claude should NEVER run 'make dev' or 'make start' commands
# These are USER-ONLY commands for starting development services

.PHONY: help dev stop status logs tail-logs health monitor clean

# Default target
help:
\t@echo "Available targets:"
\t@echo "  dev          - Start all services with shoreman (USER ONLY)"
\t@echo "  stop         - Stop all development services (USER ONLY)"
\t@echo "  status       - Show service status"
\t@echo "  logs         - Show aggregated logs"
\t@echo "  tail-logs    - Follow logs in real-time"
\t@echo "  health       - Check service health"
\t@echo "  monitor      - Show system monitoring dashboard"
\t@echo "  clean        - Clean logs and temporary files"
\t@echo ""
\t@echo "Component-specific targets:"
"""

def generate_component_targets(components_info):
    """Generate component-specific make targets."""
    targets = []
    
    for component in components_info:
        name = component.get('name', 'unknown')
        label = component.get('label', name.upper())
        
        targets.append(f"\t@echo \"  {name}-status  - Check {label} status\"")
        targets.append(f"\t@echo \"  {name}-logs    - Show {label} logs\"")
        if component.get('health_endpoint'):
            targets.append(f"\t@echo \"  {name}-health  - Check {label} health\"")
    
    return '\n'.join(targets)

def generate_dev_target(components_info):
    """Generate the dev target for starting services using shoreman."""
    content = """
# USER-ONLY COMMANDS - Claude should never execute these
dev:
\t@echo "Starting development services with shoreman..."
\t@echo "Clearing previous logs..."
\t@rm -f ./dev.log
\t@touch ./dev.log
\t@if command -v shoreman >/dev/null 2>&1; then \\
\t\tshoreman Procfile; \\
\telif command -v foreman >/dev/null 2>&1; then \\
\t\tforeman start; \\
\telse \\
\t\techo "ERROR: Neither shoreman nor foreman found."; \\
\t\techo "Run: gem install shoreman"; \\
\t\texit 1; \\
\tfi
"""
    
    return content

def generate_stop_target(components_info):
    """Generate the stop target for stopping services."""
    content = """
stop:
\t@echo "Stopping development services..."
"""
    
    # Add generic process killing based on common patterns
    kill_patterns = set()
    for component in components_info:
        start_command = component.get('start_command', '')
        if 'npm' in start_command or 'yarn' in start_command or 'pnpm' in start_command:
            kill_patterns.add('node')
        elif 'python' in start_command:
            kill_patterns.add('python')
        elif 'go run' in start_command:
            kill_patterns.add('go')
        elif 'cargo' in start_command:
            kill_patterns.add('cargo')
    
    for pattern in kill_patterns:
        content += f"\t@pkill -f '{pattern}' 2>/dev/null || true\n"
    
    content += "\t@echo \"Services stopped.\"\n"
    
    return content

def generate_status_targets(components_info):
    """Generate status checking targets."""
    content = """
# CLAUDE-ACCESSIBLE COMMANDS - Safe for AI to execute
status:
\t@echo "=== Service Status ==="
"""
    
    for component in components_info:
        name = component.get('name')
        label = component.get('label', name.upper())
        port = component.get('port')
        
        if port:
            content += f"""
\t@if curl -sf http://localhost:{port} >/dev/null 2>&1; then \\
\t\techo "{label}: ✓ Running (port {port})"; \\
\telse \\
\t\techo "{label}: ✗ Not responding (port {port})"; \\
\tfi"""
        else:
            content += f"""
\t@if pgrep -f "{name}" >/dev/null 2>&1; then \\
\t\techo "{label}: ✓ Process running"; \\
\telse \\
\t\techo "{label}: ✗ Process not found"; \\
\tfi"""
    
    # Add individual component status targets
    for component in components_info:
        name = component.get('name')
        label = component.get('label', name.upper())
        port = component.get('port')
        
        content += f"""

{name}-status:
\t@echo "=== {label} Status ==="
"""
        
        if port:
            content += f"""\t@if curl -sf http://localhost:{port} >/dev/null 2>&1; then \\
\t\techo "{label}: ✓ Running (port {port})"; \\
\telse \\
\t\techo "{label}: ✗ Not responding (port {port})"; \\
\tfi"""
        else:
            content += f"""\t@if pgrep -f "{name}" >/dev/null 2>&1; then \\
\t\techo "{label}: ✓ Process running"; \\
\telse \\
\t\techo "{label}: ✗ Process not found"; \\
\tfi"""
    
    return content

def generate_log_targets(components_info):
    """Generate log monitoring targets."""
    content = """

logs:
\t@echo "=== Recent Logs ==="
\t@if [ -f "./dev.log" ]; then tail -100 ./dev.log; else echo "No ./dev.log found"; fi

tail-logs:
\t@echo "=== Following Logs (Ctrl+C to exit) ==="
\t@echo "Killing any existing tail processes..."
\t@pkill -f "tail -f.*dev.log" 2>/dev/null || true
\t@if [ -f "./dev.log" ]; then tail -f ./dev.log; else echo "No ./dev.log found. Start services first."; fi
"""
    
    # Add component-specific log targets
    for component in components_info:
        name = component.get('name')
        label = component.get('label', name.upper())
        
        content += f"""

{name}-logs:
\t@echo "=== {label} Logs ==="
\t@if [ -f "./dev.log" ]; then grep "\\[{label}\\]" ./dev.log | tail -50; else echo "No ./dev.log found"; fi
"""
    
    return content

def generate_health_targets(components_info):
    """Generate health check targets."""
    content = """

health:
\t@echo "=== Health Check ==="
"""
    
    for component in components_info:
        name = component.get('name')
        label = component.get('label', name.upper())
        port = component.get('port')
        health_endpoint = component.get('health_endpoint', '/health')
        
        if port:
            content += f"""
\t@curl -sf http://localhost:{port}{health_endpoint} 2>/dev/null && \\
\t\techo "{label}: ✓ Healthy" || \\
\t\techo "{label}: ✗ Unhealthy"
"""
    
    # Add individual component health targets
    for component in components_info:
        name = component.get('name')
        label = component.get('label', name.upper())
        port = component.get('port')
        health_endpoint = component.get('health_endpoint', '/health')
        
        if port:
            content += f"""

{name}-health:
\t@echo "=== {label} Health ==="
\t@curl -sf http://localhost:{port}{health_endpoint} 2>/dev/null && \\
\t\techo "{label}: ✓ Healthy" || \\
\t\techo "{label}: ✗ Unhealthy"
"""
    
    return content

def generate_utility_targets():
    """Generate utility targets for monitoring and cleanup."""
    return """
monitor:
\t@echo "=== System Monitor ==="
\t@echo "Memory Usage:"
\t@free -h 2>/dev/null || vm_stat | head -5
\t@echo "Disk Usage:"
\t@df -h . | tail -1
\t@echo "Active Processes:"
\t@ps aux | head -1
\t@ps aux | grep -E "(node|python|go|cargo)" | grep -v grep | head -10 || echo "No monitored processes found"

clean:
\t@echo "Cleaning logs and temporary files..."
\t@rm -f ./dev.log *.pid
\t@echo "Clean complete"
"""

def main():
    parser = argparse.ArgumentParser(description="Generate Makefile for development monitoring")
    parser.add_argument("--components", required=True, help="JSON string of component configurations")
    parser.add_argument("--watch-patterns", help="JSON string of watch patterns (for future use)")
    parser.add_argument("--output-dir", default=".", help="Output directory")
    parser.add_argument("--output-file", default="Makefile", help="Output filename")
    
    args = parser.parse_args()
    
    try:
        components = json.loads(args.components)
    except json.JSONDecodeError as e:
        print(f"Error parsing components JSON: {e}")
        return 1
    
    if not isinstance(components, list):
        print("Components must be a JSON array")
        return 1
    
    # Generate Makefile content
    makefile_content = []
    
    # Header
    makefile_content.append(generate_makefile_header(components))
    
    # Component-specific help
    makefile_content.append(generate_component_targets(components))
    
    # Dev target (USER ONLY)
    makefile_content.append(generate_dev_target(components))
    
    # Stop target (USER ONLY)
    makefile_content.append(generate_stop_target(components))
    
    # Status targets (Claude accessible)
    makefile_content.append(generate_status_targets(components))
    
    # Log targets (Claude accessible)
    makefile_content.append(generate_log_targets(components))
    
    # Health check targets (Claude accessible)
    makefile_content.append(generate_health_targets(components))
    
    # Utility targets (Claude accessible)
    makefile_content.append(generate_utility_targets())
    
    # Write Makefile
    output_path = Path(args.output_dir) / args.output_file
    try:
        with open(output_path, 'w') as f:
            f.write('\n'.join(makefile_content))
        
        print(f"Generated Makefile: {output_path}")
        print(f"Components: {len(components)}")
        for component in components:
            name = component.get('name', 'unknown')
            label = component.get('label', name.upper())
            print(f"  - {name} ({label})")
        
        return 0
        
    except Exception as e:
        print(f"Error writing Makefile: {e}")
        return 1

if __name__ == "__main__":
    sys.exit(main())