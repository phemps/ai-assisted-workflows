#!/usr/bin/env python3

from pathlib import Path
from core.utils.tech_stack_detector import TechStackDetector, main as tech_main


def test_detect_multiple_stacks_and_exclusions(
    tmp_path: Path, tech_stacks_config_path: Path
):
    # Create config files to trigger many stacks at once
    (tmp_path / "package.json").write_text(
        "{}", encoding="utf-8"
    )  # node/react_native_expo
    (tmp_path / "app.json").write_text("{}", encoding="utf-8")  # react_native_expo
    (tmp_path / "pyproject.toml").write_text(
        "[tool.poetry]", encoding="utf-8"
    )  # python
    (tmp_path / "pom.xml").write_text("<project/>", encoding="utf-8")  # java_maven
    (tmp_path / "build.gradle").write_text("plugins{}", encoding="utf-8")  # java_gradle
    (tmp_path / "proj.csproj").write_text("<Project/>", encoding="utf-8")  # dotnet
    (tmp_path / "go.mod").write_text("module x", encoding="utf-8")  # go
    (tmp_path / "Cargo.toml").write_text("[package]", encoding="utf-8")  # rust
    (tmp_path / "composer.json").write_text("{}", encoding="utf-8")  # php
    (tmp_path / "Gemfile").write_text(
        "source 'https://rubygems.org'", encoding="utf-8"
    )  # ruby
    (tmp_path / "CMakeLists.txt").write_text("project(X)", encoding="utf-8")  # cpp
    (tmp_path / "Package.swift").write_text(
        "// swift-package", encoding="utf-8"
    )  # swift
    (tmp_path / "build.gradle.kts").write_text("plugins{}", encoding="utf-8")  # kotlin

    detector = TechStackDetector.from_config(tech_stacks_config_path)
    stacks = set(detector.detect_tech_stack(str(tmp_path)))

    # Ensure a representative subset was detected
    for key in [
        "node_js",
        "react_native_expo",
        "python",
        "java_maven",
        "java_gradle",
        "dotnet",
        "go",
        "rust",
        "php",
        "ruby",
        "cpp",
        "swift",
        "kotlin",
    ]:
        assert key in stacks

    excl = detector.get_simple_exclusions(str(tmp_path))
    # Sanity checks for a few stack-specific exclusions
    assert "node_modules" in excl["directories"]
    assert "target" in excl["directories"] or "build" in excl["directories"]
    assert ".dll" in excl["extensions"] or ".class" in excl["extensions"]


def test_should_analyze_file_and_vendor_detection(
    tmp_path: Path, tech_stacks_config_path: Path
):
    detector = TechStackDetector.from_config(tech_stacks_config_path)
    # Ensure node/react stacks are detected for directory exclusion checks
    (tmp_path / "package.json").write_text("{}", encoding="utf-8")

    # Excluded by directory name
    nd = tmp_path / "node_modules" / "lib.js"
    nd.parent.mkdir(parents=True, exist_ok=True)
    nd.write_text("console.log('x')\n", encoding="utf-8")
    assert detector.should_analyze_file(str(nd), str(tmp_path)) is False

    # Generated file marker should be excluded
    gen = tmp_path / "gen.js"
    gen.write_text("// Generated by tool\n", encoding="utf-8")
    assert detector.should_analyze_file(str(gen), str(tmp_path)) is False

    # Vendor marker inside src path should not be excluded (treated as first-party)
    srcf = tmp_path / "src" / "app.js"
    srcf.parent.mkdir(parents=True, exist_ok=True)
    srcf.write_text("// lodash utility\n", encoding="utf-8")
    assert detector.should_analyze_file(str(srcf), str(tmp_path)) is True

    # Minified-like very long line should be treated as generated/vendor
    mini = tmp_path / "min.js"
    mini.write_text("x" * 600 + "\n", encoding="utf-8")
    assert detector.should_analyze_file(str(mini), str(tmp_path)) is False

    # Unreadable path (directory passed as file) exercises IOError branch
    assert (
        detector.should_analyze_file(str(tmp_path / "not_a_file"), str(tmp_path))
        is True
    )

    # Vendor marker outside dev dirs should be excluded
    vend = tmp_path / "third_party.js"
    vend.write_text("// jquery min\n", encoding="utf-8")
    assert detector.should_analyze_file(str(vend), str(tmp_path)) is False

    # Excluded file names and extensions
    envf = tmp_path / ".env"
    envf.write_text("A=1\n", encoding="utf-8")
    assert detector.should_analyze_file(str(envf), str(tmp_path)) is False

    logf = tmp_path / "app.log"
    logf.write_text("x\n", encoding="utf-8")
    assert detector.should_analyze_file(str(logf), str(tmp_path)) is False


def test_tech_stack_detector_cli_main(
    tmp_path: Path, tech_stacks_config_path: Path, monkeypatch
):
    # Prepare a small project with multiple stack signals
    (tmp_path / "package.json").write_text("{}", encoding="utf-8")
    (tmp_path / "pyproject.toml").write_text("[tool]", encoding="utf-8")

    import sys

    argv_bak = sys.argv[:]
    sys.argv = ["tech", str(tmp_path), "--format", "report"]
    try:
        tech_main()
    finally:
        sys.argv = argv_bak
