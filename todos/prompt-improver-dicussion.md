<!-- Generated by SpecStory -->

# Implementing a prompt improver function in VS Code (2025-08-12 10:08Z)

_**User**_

using vscode as my main ide, I want to explore options for how to introduce a prompt improver function. I want to enable this kind of feature user flow:

- user enters instructions into the active text entry, which could be copilots chat window, it could be terminal for conversation with a cli agent like claude code, it could inline prompting whilst editing a code file.
- user has finished entering their instructions and pushes a keyboard shortcut - this triggers the prompt improver
- the prompt improver will use the model of choice (can be configured through settings) and will have its own system prompt on what rules it shoudl apply to improving the user input from one of the above text entry scenarios, replacing the user input with its improved version.
- ideally it would have an approval / rollback option as part of confirming whether the user approves of the new input iteration, but for now, this is can be seen as a nice to have.

We have the constraint that the LLM capability needs to come from an existing subscription, i have github copilot and claude code max.

I am open to ideas on how this is implemented, i would like you to explore options (feel free to use brave search for research) - it feels like its probably a vs code extension with the need for that context awareness of where the user text input needs to be read/updated.

---

_**Assistant**_

Researching VS Code APIs and feasibility (chat, inline chat, terminal interception) to ground option recommendations. Looking up VS Code API for intercepting terminal input or editing before send. Researching APIs for keybinding and reading editor selection or chat input. Here's a structured exploration of realistic implementation paths for a ‚ÄúPrompt Improver‚Äù in VS Code given your flow and the Copilot + Claude Code Max constraint.

## ‚úÖ Requirements Checklist

- Transform user-entered instructions across contexts (chat panel, inline prompt, terminal, editor).
- Trigger via keyboard shortcut after user finishes typing.
- Use existing subscriptions only (GitHub Copilot, Claude Code Max) ‚Äî avoid requiring new paid APIs.
- Apply a system prompt / ruleset to improve the prompt.
- Replace original input with improved version.
- (Optional) Approval / rollback.

All covered below; where something is limited by VS Code APIs I call it out with workarounds.

## üß≠ Key Constraints & Realities

1. You cannot (today) directly modify the Copilot Chat input box or another extension‚Äôs webview contents. Sandboxed.
2. You can add:
   - A Chat Participant (via Chat API) that returns an improved prompt.
   - Slash commands / buttons inside your participant‚Äôs responses.
3. Terminal interception before send isn‚Äôt supported natively. Workarounds:
   - Use a pseudo-terminal you control.
   - Or provide a command that captures text (selection / input box) and then injects improved text via `terminal.sendText()`.
4. Inline editor prompting: fully feasible via selection + command + WorkspaceEdit.
5. Using ‚Äúexisting subscriptions‚Äù:
   - GitHub Copilot models aren‚Äôt programmatically callable for arbitrary transform except through Chat Participant usage flows.
   - Claude Code Max: If it exposes a CLI (e.g. `claude`) you can spawn it; if not, you‚Äôd need an Anthropic API key (might fall outside ‚Äúexisting subscription‚Äù unless that plan grants you one). Provide pluggable providers so you can later slot in a local model or API.
6. Approval UI: easy via QuickPick, diff view, or Chat buttons.

## üß© Option Matrix

| Option                                                              | Contexts Covered                    | Intrusiveness | Uses Existing Subs?              | Pros                       | Cons                                   |
| ------------------------------------------------------------------- | ----------------------------------- | ------------- | -------------------------------- | -------------------------- | -------------------------------------- |
| A. Simple Command (selection ‚Üí improved)                            | Editor                              | Low           | Any (spawn Claude CLI or LM API) | Fast MVP                   | Doesn‚Äôt touch chat/terminal            |
| B. Chat Participant (@promptPolish)                                 | Chat panel                          | Medium        | Copilot infra allowed            | Native chat UX, buttons    | User must copy result back into input  |
| C. Slash Command (/improve last message)                            | Chat                                | Medium        | Copilot chat                     | Feels integrated           | Cannot silently replace original input |
| D. Inline Code Action (marker + code action)                        | Editor                              | Low           | Any                              | Discoverable via lightbulb | Requires marker pattern or selection   |
| E. Pseudo-Terminal Wrapper (your agent shell)                       | Terminal                            | Higher        | Any                              | True intercept & replace   | Must reimplement readline features     |
| F. ‚ÄúStaging‚Äù Input Box Flow (Command Palette improves then injects) | Editor + Terminal + Chat (indirect) | Low           | Any                              | Unified UX, simple         | Slight context hop for user            |
| G. Webview Prompt Pad (floating panel)                              | All (indirect)                      | Medium        | Any                              | Central hub adding context | Extra UI surface                       |
| H. Local LM (optional later)                                        | All (same as above)                 | Medium        | Future                           | Offline / privacy          | Model mgmt overhead                    |

Recommended phased path: A ‚Üí F ‚Üí B/C ‚Üí E (if terminal polish really needed).

## üèóÔ∏è Proposed Architecture (Extensible Spine)

Core pieces:

- Command: `promptImprover.improve` (bound to e.g. `cmd+shift+;`)
- Context collector: gathers
  - Active selection / entire line
  - Surrounding N lines (config)
  - Open file language id
  - Optional other open editors (limited to top K)
- Provider abstraction:
  ```
  interface PromptModelProvider {
    name: string;
    improve(input: string, meta: ContextMeta, rules: string): Promise<string>;
  }
  ```
  Implementations: `ClaudeCliProvider`, `AnthropicApiProvider` (optional), `MockProvider`.
- System prompt rule engine: Load from user setting or workspace file (`.prompt-improver/system.md`).
- Approval UI:
  - QuickPick: "Accept / Reject / Show Diff"
  - Diff: register `vscode.TextDocumentContentProvider` for original vs improved.
- Replacement strategy:
  - Editor: `WorkspaceEdit.replace`
  - Terminal: `terminal.sendText(improved, /* addNewLine */ false)` (after clearing original line via sending `\u0015` (Ctrl+U) if shell supports)
  - Chat: return improved version (user copies) OR inside Chat Participant present Accept button copying to clipboard automatically (`vscode.env.clipboard.writeText`)

## ‚öôÔ∏è Handling Each Context

1. Editor (most reliable)

   - If selection non-empty ‚Üí treat as prompt.
   - Else if line starts with comment prefix (language-aware) and user triggers command ‚Üí treat trimmed line (support multi-line contiguous comment block).
   - Optional heuristic: preceding comment block before a code selection.

2. Terminal

   - Easiest: Provide separate command ‚ÄúCapture Current Line to Improve‚Äù:
     - Prompt user for current text (InputBox prefilled from last used).
     - Improve.
     - Send improved text.
   - Advanced: pseudo-terminal:
     - Create `vscode.window.createTerminal({ name: 'Agent Shell', pty })`
     - Maintain buffer; when user presses bound key you transform buffer before echo + dispatch to underlying spawned shell process.
     - Edge cases: cursor repositioning, multi-line editing, history integration.

3. Chat
   - Add a Chat Participant (e.g. `@PromptPolish`) with instructions: user pastes raw prompt ‚Üí gets improved variant + optional Accept button.
   - Slash command: register via Chat API (if available in your VS Code version) to operate on last user message (the API gives conversation messages).
   - Limitation: cannot auto-overwrite the text in Copilot‚Äôs input field; must provide copy action.

## üîí Copilot & Claude Integration Notes

- Copilot: Only through Chat Participant; you cannot call `gpt-4` provider directly; rely on VS Code‚Äôs internal LM selection with `vscode.lm.selectChatModels()` (proposed API ‚Äî ensure `enableProposedApi` in `package.json`).
- Claude Code Max: If it ships a CLI (e.g. `claude --improve` hypothetical), wrap spawn. If not, you likely need an Anthropic API key (check subscription terms). Provide pluggable config but default to ‚ÄúClipboard-only mode‚Äù if provider not configured.

## üß™ Edge Cases & Mitigations

- Very short prompts: skip improvement (config: min length).
- Sensitive content: allow a pass-through if regex matches secrets (don‚Äôt send).
- Rate limits: queue requests; show status bar spinner.
- Multi-cursor selections: improve each independently (option) or join with separators.
- Large selection: truncate with note (‚Äú‚Ä¶truncated context for improvement‚Äù).

## üõ†Ô∏è Minimal Extension Skeleton (Key Parts)

package.json (excerpt):

```
{
  "name": "prompt-improver",
  "activationEvents": ["onCommand:promptImprover.improve", "onCommand:promptImprover.improveTerminal"],
  "contributes": {
    "commands": [
      { "command": "promptImprover.improve", "title": "Prompt Improver: Improve Selection" },
      { "command": "promptImprover.improveTerminal", "title": "Prompt Improver: Improve for Terminal" }
    ],
    "keybindings": [
      { "command": "promptImprover.improve", "key": "cmd+shift+;", "when": "editorTextFocus" },
      { "command": "promptImprover.improveTerminal", "key": "cmd+shift+;", "when": "terminalFocus" }
    ],
    "configuration": {
      "properties": {
        "promptImprover.modelProvider": {
          "type": "string",
            "enum": ["claudeCli", "anthropicApi", "mock"],
            "default": "mock"
        },
        "promptImprover.systemPrompt": { "type": "string", "default": "Improve the prompt..." },
        "promptImprover.autoReplace": { "type": "boolean", "default": false },
        "promptImprover.showDiff": { "type": "boolean", "default": true }
      }
    }
  }
}
```

extension.ts (core logic excerpt):

```ts
import * as vscode from "vscode"

interface ContextMeta {
  language?: string
  fileName?: string
}
interface PromptModelProvider {
  name: string
  improve(input: string, meta: ContextMeta, rules: string): Promise<string>
}

class MockProvider implements PromptModelProvider {
  name = "mock"
  async improve(input: string) {
    return `[IMPROVED]\n${input.trim()}\n(clarified automatically)`
  }
}

// Claude CLI provider example (assumes a `claude` binary that reads stdin)
class ClaudeCliProvider implements PromptModelProvider {
  name = "claudeCli"
  async improve(input: string, meta: ContextMeta, rules: string) {
    const proc = await import("node:child_process")
    return new Promise<string>((resolve, reject) => {
      const p = proc.spawn("claude", ["--mode", "improve"], {
        stdio: ["pipe", "pipe", "pipe"],
      })
      let out = ""
      let err = ""
      p.stdout.on("data", (d) => (out += d.toString()))
      p.stderr.on("data", (d) => (err += d.toString()))
      p.on("close", (code) =>
        code === 0
          ? resolve(out.trim())
          : reject(new Error(err || `Exit ${code}`)),
      )
      p.stdin.write(`SYSTEM:\n${rules}\n\nPROMPT:\n${input}\n`)
      p.stdin.end()
    })
  }
}

function getProvider(kind: string): PromptModelProvider {
  switch (kind) {
    case "claudeCli":
      return new ClaudeCliProvider()
    default:
      return new MockProvider()
  }
}

async function improveRaw(raw: string) {
  const cfg = vscode.workspace.getConfiguration("promptImprover")
  const provider = getProvider(cfg.get("modelProvider") as string)
  const systemPrompt = cfg.get("systemPrompt") as string
  const editor = vscode.window.activeTextEditor
  const meta: ContextMeta = editor
    ? {
        language: editor.document.languageId,
        fileName: editor.document.fileName,
      }
    : {}
  return provider.improve(raw, meta, systemPrompt)
}

async function approveAndApply(
  original: string,
  improved: string,
  apply: (text: string) => void,
) {
  const cfg = vscode.workspace.getConfiguration("promptImprover")
  if (cfg.get("autoReplace")) {
    apply(improved)
    return
  }
  const showDiff = cfg.get("showDiff")
  const picks = ["Accept", "Reject", showDiff ? "View Diff" : undefined].filter(
    Boolean,
  ) as string[]
  let decision = await vscode.window.showQuickPick(picks, {
    placeHolder: "Prompt Improver result",
  })
  if (decision === "View Diff") {
    const originalUri = vscode.Uri.parse("prompt-improver://original")
    const improvedUri = vscode.Uri.parse("prompt-improver://improved")
    const provider: vscode.TextDocumentContentProvider = {
      provideTextDocumentContent: (uri) =>
        uri.path.endsWith("original") ? original : improved,
    }
    const reg = vscode.workspace.registerTextDocumentContentProvider(
      "prompt-improver",
      provider,
    )
    await vscode.commands.executeCommand(
      "vscode.diff",
      originalUri,
      improvedUri,
      "Prompt Diff",
    )
    reg.dispose()
    decision = await vscode.window.showQuickPick(["Accept", "Reject"])
  }
  if (decision === "Accept") apply(improved)
}

async function improveSelectionCommand() {
  const editor = vscode.window.activeTextEditor
  if (!editor) return
  const sel = editor.selection
  const text = sel.isEmpty
    ? editor.document.lineAt(sel.active.line).text
    : editor.document.getText(sel)
  if (!text.trim()) return
  const improved = await vscode.window.withProgress(
    { location: vscode.ProgressLocation.Window, title: "Improving prompt..." },
    () => improveRaw(text),
  )
  await approveAndApply(text, improved, (replacement) => {
    const edit = new vscode.WorkspaceEdit()
    const range = sel.isEmpty
      ? editor.document.lineAt(sel.active.line).range
      : sel
    edit.replace(editor.document.uri, range, replacement)
    vscode.workspace.applyEdit(edit)
  })
}

async function improveTerminalCommand() {
  const term = vscode.window.activeTerminal
  if (!term) {
    vscode.window.showInformationMessage("No active terminal")
    return
  }
  const original = await vscode.window.showInputBox({
    prompt: "Prompt to improve (will be sent after accept)",
  })
  if (!original) return
  const improved = await vscode.window.withProgress(
    { location: vscode.ProgressLocation.Window, title: "Improving prompt..." },
    () => improveRaw(original),
  )
  await approveAndApply(original, improved, (replacement) => {
    term.sendText(replacement, false)
  })
}

export function activate(ctx: vscode.ExtensionContext) {
  ctx.subscriptions.push(
    vscode.commands.registerCommand(
      "promptImprover.improve",
      improveSelectionCommand,
    ),
    vscode.commands.registerCommand(
      "promptImprover.improveTerminal",
      improveTerminalCommand,
    ),
  )
}

export function deactivate() {}
```

(Anthropic / Chat Participant variants would extend this, but omitted for brevity.)

## üß™ Future Enhancements

- Context enrichment: automatically include top N open file names & language metadata in system prompt.
- Inline Chat integration: register chat participant with accept/copy button.
- Pseudo-terminal mode for full intercept.
- User-defined transformation chains (lint ‚Üí clarify ‚Üí shorten).
- Telemetry (opt‚Äëin) to measure acceptance ratio.

## üîÅ Approval / Rollback Patterns

- Simple: QuickPick (implemented).
- Advanced: Diff view pre-accept (supported).
- For editor: On accept, store original in a ring buffer; add command ‚ÄúUndo Last Prompt Improvement‚Äù keyed to that buffer separate from normal undo (use `Memento` storage).

## üöß Risks & Mitigations

| Risk                              | Mitigation                                                                 |
| --------------------------------- | -------------------------------------------------------------------------- |
| Provider fails / rate limit       | Graceful fallback with mock provider; surface error message, keep original |
| Large prompt cost                 | Truncate with ellipsis + notify                                            |
| Secrets exfiltration              | Regex scrub (keys, tokens) before send; warn user                          |
| User confusion about context used | Status bar clickable item summarizing context size                         |
| API changes (proposed LM API)     | Feature flag; degrade to external CLI                                      |

## üó∫Ô∏è Recommended Incremental Plan

1. MVP (Day 1‚Äì2): Command + selection + mock provider + config + approval UI.
2. Add Claude CLI provider (spawn) & system prompt file override.
3. Add terminal command.
4. Add chat participant.
5. Optional pseudo-terminal shell.
6. Add context inspector + diff persistence.

## üìå Summary

You can deliver a robust prompt improver with a small VS Code extension spine that:

- Normalizes input capture per context.
- Routes through a pluggable provider layer using only subscriptions you already hold.
- Offers optional approval with diff.
- Scales later to deeper chat & terminal integration.

If you‚Äôd like, next step I can scaffold the actual extension structure in your repo. Just say the word and what provider you want first (mock vs Claude CLI). Let me know and I‚Äôll implement phase 1.

---

_**User**_

could you explain the user flow of how your prototype would function, I dont quite follow what you are suggesting?

---

_**Assistant**_

Task: Clarify the end‚Äëto‚Äëend user flow for the proposed Prompt Improver prototype.
Plan: Break down each context (editor, terminal, chat) into concrete step sequences; distinguish MVP vs later enhancements; show how keyboard shortcut, approval, replacement, and providers interplay.

## Core Mental Model

One keyboard shortcut (e.g. Cmd+Shift+;) triggers ‚ÄúImprove current prompt‚Äù in whatever context you‚Äôre focused. The extension:

1. Captures candidate text (selection, line, typed prompt, or user-entered via a quick input).
2. Sends it (plus lightweight metadata) to a chosen model provider with a system rule set.
3. Returns an improved version.
4. Lets you accept (replace/inject), view diff first, or reject.
5. (Optional later) Offers rollback and richer context.

## MVP User Flows

### 1. Editor: Improve Selected Text (Primary Flow)

1. You highlight a block of instructions (could be a TODO block, a prompt draft, commit message draft).
2. Press Cmd+Shift+;.
3. Status bar shows ‚ÄúImproving prompt‚Ä¶‚Äù.
4. QuickPick pops up with:
   - Accept
   - Reject
   - View Diff (if enabled in settings)
5. If Accept:
   - The selected text is replaced in-place with the improved version.
6. If View Diff:
   - A diff tab opens (Original vs Improved).
   - After reviewing, another QuickPick (Accept / Reject).
7. If Reject: no changes.

If no selection:

- It defaults to the current line (helpful for single-line prompts or commit-message style lines).
- If the line (or contiguous preceding lines) are all comments, it treats the contiguous comment block as the prompt.

### 2. Editor: Multi-Cursor (Optional Setting)

- You place multiple cursors, select different partial prompts.
- Trigger command; extension either:
  a) Improves each chunk independently (returns a combined QuickPick summary then applies all), or
  b) (Default MVP) Warns and asks to collapse to a single selection.

### 3. Terminal: Simple ‚ÄúImprove Before Send‚Äù

Because VS Code can‚Äôt intercept what you already typed in a stock terminal line:

1. You press Cmd+Shift+; while focused in the terminal.
2. An input box appears prefilled with (a) last prompt you improved or (b) empty; you paste or retype what you were about to send.
3. On Enter, it runs improvement.
4. Approval step (same as editor).
5. On Accept: it injects the improved text into the terminal input (without auto-sending newline unless you configured ‚ÄúautoSend‚Äù).
6. You press Enter manually (or autoSend does it if enabled).

### 4. Chat Panel: Using a Chat Participant (@PromptPolish)

1. You open Copilot / Chat panel.
2. Type raw messy prompt.
3. Instead of sending, you:
   - Select it and copy, then type: @PromptPolish <paste> (or)
   - Use a slash command /improve (future) that refers to your just-typed text.
4. The participant responds with:
   - Improved prompt (formatted)
   - Buttons: [Copy Improved] [Copy Original] (and possibly rationale).
5. You click Copy Improved and paste it back into the normal chat input, then send.

Limitation: It cannot auto-overwrite the chat input box (sandbox constraint).

### 5. Approval / Diff Mechanics

- If ‚ÄúshowDiff = true‚Äù: You can inspect changes before committing.
- Diff uses a virtual scheme (no temp files on disk).
- Accept writes; Reject discards; Undo still works with standard editor undo plus optional internal ‚Äúimprovement history‚Äù stack (later enhancement).

### 6. Settings Influence

In Settings UI (or settings.json):

- promptImprover.modelProvider = mock | claudeCli | anthropicApi
- promptImprover.systemPrompt = ‚ÄúImprove the user‚Äôs instructions by‚Ä¶‚Äù
- promptImprover.autoReplace = true/false
- promptImprover.showDiff = true/false
- promptImprover.contextLines = N (future: number of surrounding lines to send as meta)
  Changing these immediately affects next invocation (no reload needed unless provider initialization changes).

### 7. System Prompt Source

Priority order:

1. Workspace file .prompt-improver/system.md (if exists)
2. User setting promptImprover.systemPrompt
3. Built-in default

### 8. Provider Flow (Example: Claude CLI)

1. After capture, extension builds payload:
   - SYSTEM: (rules)
   - META: {language, filename}
   - PROMPT: (user text)
2. Spawns the CLI process (e.g. claude --mode improve).
3. Reads stdout (improved text).
4. Handles errors gracefully (falls back to original + toast message).

Mock provider: Always returns a deterministic annotated improvement for offline testing.

### 9. Failure Scenario

- Provider times out or returns error ‚Üí Notification ‚ÄúImprovement failed (provider timeout). Original text untouched.‚Äù
- You can retry (command again).
- No partial replacements occur.

### 10. Undo / Rollback (Phase 2)

- On Accept, original text is pushed to an internal stack (Memento).
- Command: ‚ÄúPrompt Improver: Undo Last Replacement‚Äù.
- If triggered, it restores last replaced region (if still valid). If file changed drastically, warns and offers to insert original at cursor instead.

### 11. Pseudo-Terminal (Later Enhancement)

Replaces stock shell:

1. You open ‚ÄúAgent Shell‚Äù.
2. Type a line.
3. Press Cmd+Shift+; before Enter.
4. It captures the current buffer (internal), improves, redraws improved line (like an inline rewrite), cursor at end.
5. Press Enter to execute.
   This gives a more ‚Äúmagical‚Äù feel but requires reimplementing line-edit behavior.

### 12. Context Enrichment (Later)

When you trigger improvement in editor:

- Extension optionally scrapes up to N open filenames and the current file language to embed (e.g., ‚ÄúUser is in TypeScript file myFile.ts‚Äù).
- Not inserted into final prompt text‚Äîjust influences model response.

### 13. Security / Secret Guard

Before sending:

- Regex scan for patterns (API keys).
- If found, prompt: ‚ÄúPotential secret detected in prompt body. Send anyway? (Send / Cancel / Open Sanitized View)‚Äù
- Sanitized view masks secrets with \*\*\*\*.

### 14. Performance Feedback

- Status bar spinner while pending.
- If response > threshold length, trimmed diff view by default (toggle ‚ÄúView Full‚Äù).

## Flow Summary Cheat Sheet

Editor (selection) ‚Üí Shortcut ‚Üí Capture text ‚Üí Provider ‚Üí Approve/Diff ‚Üí Replace.

Editor (no selection) ‚Üí Use current line or comment block ‚Üí Same as above.

Terminal (standard) ‚Üí Shortcut ‚Üí InputBox (user supplies line) ‚Üí Provider ‚Üí Approve ‚Üí Inject line (optionally auto-send).

Chat ‚Üí Use @PromptPolish participant ‚Üí Response contains improved prompt + copy button ‚Üí User pastes back.

Pseudo-Terminal (future) ‚Üí Shortcut rewrites in place prior to send.

## What You Do as a User

1. Write rough prompt.
2. Hit one shortcut.
3. Glance at improved output; optionally inspect diff.
4. Accept (or reject).
5. Continue workflow with polished prompt.

## Next Step (If You Want)

I can scaffold Phase 1 (editor selection + mock provider + approval UI) directly in the repo. Just confirm you‚Äôd like that and (optional) preferred extension folder name.

Let me know if you want the scaffold implemented now or want any part adjusted first.

---
